{{ :wiki:img_20140327_095643.jpg?500 |}}

Soit une séquence référence au format Fasta : ref.fasta

Cas simple la référence est petite, moins de 32000 bases.
Voir aussi le cas compliqué où [[cas compliqué|la référence contient au moins une séquence de plus de 32K]]

Soit un ou plusieurs fichiers de reads au format **fastQ** : 
 p.ex. SRR022822.fastq

1) La première étape est de construire l'index BWT de la référence fasta:

<code> bowtie-build ref.fasta rbwt
</code>

Ici rbwt servira de "nom pratique à utiliser" c'est le surnom de notre référence.

Cela créera 6 fichiers *.ebwt
<code>
-rw-r--r-- 1 root root 4194945 Mar 27 08:31 rbwt.1.ebwt
-rw-r--r-- 1 root root     156 Mar 27 08:31 rbwt.2.ebwt
-rw-r--r-- 1 root root      17 Mar 27 08:31 rbwt.3.ebwt
-rw-r--r-- 1 root root     298 Mar 27 08:31 rbwt.4.ebwt
-rw-r--r-- 1 root root 4194945 Mar 27 08:31 rbwt.rev.1.ebwt
-rw-r--r-- 1 root root     156 Mar 27 08:31 rbwt.rev.2.ebwt
</code>


2) La seconde étape consiste à ne garder parmi les reads que ceux qui ont
qqchose en commun avec la référence précédemment indexée, en utilisant l'index ebwt juste construit.

Soit pour le fichier fastq SRR022822.fastq

<code>
Syntaxe générale:
bowtie ref fastqfile --al fich_seq_conservées --un fich_seq_exclues logfile

ex:
bowtie rbwt SRR022822.fastq --al keep --un unkeep log
</code>

--al keep   <= cela créera un fichier fastq appelé keep contenant uniquement
les séquences (--ALignées)

--un unkeep <= créera un fichier fastq appelé unkeep des séquences non alignables à la référence (--UNaligned)

plus utilement, si on est intéressé uniquement par les séquences utiles, 
et que l'on ne veut pas des séquences exclues il est utile de diriger les 
séquences exclues vers le "vide" (tout comme les logs) dans un souçi de
rapidité:
<code>
bowtie rbwt SRR022822.fastq --al keep --un /dev/null /dev/null
# reads processed: 2736791
# reads with at least one reported alignment: 854 (0.03%)
# reads that failed to align: 2735937 (99.97%)
Reported 854 alignments to 1 output stream(s)
</code>
La commande rapporte le nb de séquence (reads) trouvées dans la source, le nb 
de reads conservés (qui ont un rapport avec la référence), et le nb de reads 
exclus de la source (sans rapport avec la référence)

3) mapping au format SAM des reads sélectionnés par rapport à la référence:
<code>
Syntaxe:
       bowtie -S reference keep keep.sam
p.ex:
       bowtie -S rbwt keep25 25.sam
       bowtie -S rbwt keep23 23.sam
       ...
       ...
</code>
Ce qui recrée au format SAM, des fichiers correspondants aux reads conservés
mais "mappés" par rapport à la référence indexée.

<code>
-rw-r--r-- 1 root root 140066 Mar 27 09:01 23.sam
-rw-r--r-- 1 root root 132623 Mar 27 09:01 25.sam
</code>


4) velvet

Comme d'ordinaire velvet s'exécute en 2 étapes:

Syntaxe avec référence:
<code>
velveth dossierprojet kmerint -reference reference.fasta -short -sam filtered_reads_files.sam
velvetg dossierprojet -exp_cov auto -amos_file yes
</code>
p.ex:
<code>
velveth AliAvecRef 25 -reference ref.fasta -short -sam 23.sam 25.sam
velvetg AliAvecRef -exp_cov auto -amos_file yes
</code>

** !! Important !! ** 

pour velveth c'est bien le fichier **FASTA** de la référence qui est utilisé !

Les fichiers SAM, des reads filtrés, sont des indications de placement des reads eux-mêmes par rapport à cette séquence fasta.

Il peut y avoir plusieurs séquences fasta dans le fichier de référence, par exemple des contigs issus d'un assemblage préalable, des chromosomes connus
d'un organisme, ou tout simplement une série de gènes dont on veut analyser
l'expression plutot que le tout. 
L'étape bowtie permet de filtrer, de ne conserver que les reads qui interviennent
dans un processus que l'on étudie, et d'accélérer l'assemblage en positionnant
les reads filtrés directement sur les séquences références.
