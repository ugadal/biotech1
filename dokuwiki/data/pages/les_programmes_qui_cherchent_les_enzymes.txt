__**Exécuter en une ligne de commande**__

Donc nous avons vu que la commande **remap**, commande qui donne des informations sur les enzymes qui coupent dans la séquende ou non,acceptait certaines options :
-enzymes
-sitelen
-outfile
-sbeg
-send
-etc..

Il y en a d'autres mais celles-ci nous aiderons le plus.

**L'objectif :**
Il est de connaitre les enzymes qui ne coupent pas dans une région voulu d'une séquence.
Donc la ligne de commande ressemblerai à cela :

<code> 
remap la_sequence 
-enzymes all ou -enzymes @fichier 
-sbeg nombre  début de séquence optionnel
-send nombre  fin de séquence optionnel
-outfile stdout </code>

La suite est d'établir un programme qui reçoit des arguments à la ligne de commande pour chaque option, de ce fait les options ne seront plus à taper à la ligne de commande.

Le premier essai fut de récuperer les arguments :
<file bash>
seq=$1
beg=$2
end=$3
enz=$4
if [ $beg == - ]
then
	beg=""
else 
	beg="-sbeg $beg"
fi


if [ $end == - ]
then
	end=""
else 
	end="-send $end"
fi
remap $seq $beg $end -sitelen 6 -enzymes $enz -outfile tmp1 #~ On écrit dans un fichier temporaire pour pouvoir le modifier par après.
</file>

Après cela, nous obtenons le fichier avec les informations voulues, mais avec des informations superflues.
Ce que nous voulions était juste les enzymes qui ne coupent pas la séquence, donc le programme **sed** était requis. 

<file bash>
sed -i -e "0,/# Enzymes that do not cut/ d" tmp1
		#~ Retire tout ce qu'il y a avant la phrase, elle comprise 
sed -i -e "/# No. of cutting enzymes which do not match the/,$ d" tmp1
		#~ Retire tout ce qu'il a après cette phrase, elle comprise, jusqu'à la fin 
sed -i -e "s/\s\+/,/g" tmp1
                #~ substitue les espaces par des virgules
</file>

Avec ces 2 script nous obtenons une liste d'enzymes comme ceci :
<file>
AatII,AbsI,AclI,AcyI,AflII,AloI,ApaI,ApaLI,
AscI,BaeI,BarI,BbvCI,BglI,BmtI,BplI,Bpu10I,
BsaAI,BsaXI,BsePI,BseRI,BseSI,BseYI,BsgI,BsiI*,
Bsp120I,BspHI,BspLU11I*,BspMII*,BspOI,BstAPI,BtrI,Cfr9I,
ClaI,DinI,DraIII,DrdI,Eam1105I,EciI,Ecl136II,Eco31I,
Eco47III,Eco53kI,EcoICRI,EcoRI,EcoRV,EgeI,EheI,Esp3I,
EspI*,FalI,FseI,GsaI,HaeII,HgiAI*,HindIII,I-CeuI,
I-PpoI,I-SceI,KasI,KroI,MauBI,McrI*,MluI,MroNI,
NaeI,NarI,NcoI,NgoMIV,NheI,NmeAIII,NotI,NruI,
PacI,PasI,PflMI,PfoI,PI-PspI,PI-SceI,PluTI,PmaCI,
PmeI,PspOMI,PsrI,PvuI,SacI,SacII,SalI,SanDI*,
SauI*,ScaI,SexAI,SfiI,SfoI,SgfI,SgrAI,SgrDI,
SmaI,SnaBI,SpeI,SplI*,SrfI,Sse232I*,Sse8387I,SspDI,
SwaI,TspMI,Tth111I,XmaI,XmaIII*,ZraI,
</file>

Par soucis de lisibilité et d'esthétique nous voulons retirer la virgule de fin, retirer les lignes vides et remplacer les virgules par des retour à la ligne 

<file>
sed -i -e "s/\s\+/,/g"
sed -i -e "s/,$//"
sed -i -e "/^$/d"
sed -i -e "s/,/\n/g"
</file>

__**Le problème**__
Nous ne voulons pas qu'un fichier temporaire soit créé car si 2 utilisateurs le lance en même temps il y aura des problèmes.
L'idée pour contourner cela est de faire un programme exécutable par le shell en lui disant que c'est du **sed**.
Voici le code du sed pour le programme des enzymes qui ne coupent pas :
<file sed>

#!/bin/sed -f
0,/# Enzymes that do not cut/ d
/# No. of cutting enzymes which do not match the/,$ d
s/\s\+/,/g
s/,$//
/^$/d
s/,/\n/g
</file>

Voici le code du sed pour le programme des enzymes qui coupent :
<file sed>
#!/bin/sed -f
0,/# Enzymes that cut\s\+Frequency\s\+Isoschizomers/ d
/# Enzymes which cut less frequently than the MINCUTS criterion/,$ d
s/\s\+\(\S\+\)\s\+.*/\1/
/^$/d
</file>

A ce stade le code ressemble à ceci :
<file bash>
seq=$1
beg=$2
end=$3
enz=@$4

if [ $beg == - ]
then
	beg=""
else 
	beg="-sbeg $beg"
fi


if [ $end == - ]
then
	end=""
else 
	end="-send $end"
fi
remap $seq $beg $end -sitelen 6 -enzymes $enz -outfile stdout | ./sedc ou ./sednc
</file>

**Rm:** pour rendre les "sed" ou le (no)cutters éxecutable il faut faire un **chmod 755**, et seulement quand tout fonctionne bien on peut les déplacer dans **/usr/local/bin**.

__**Le //$0// et les liens**__
Essayons le code test ci-dessous :
<file bash test.sh>
if [ $1 == false ]
then
	echo $0
elif [ $1 != false ]
then
	echo @$1
fi
</file>
Si l'argument est le mot "false" alors il va retourner le nom du programme lancé.
Cet commande sera très utile avec les propriétés des liens.

Lorsque l'on créé un lien d'un programme, exemple :
<file>
ln -s tester.sh cutter
</file>
Cela crée un lien. Cela veut dire que si on demande le programme cutter il va nous envoyer sur le tester.sh **mais** le //$0// ne sera pas le même si on lance l'un ou l'autre.

Donc au lieu de créer 2 programmes, un cutters et un no cutters, nous faisons un lien de cutters vers nocutters :
<file bash>
ln -s nocutters cutters
</file>

Et pour que le programme puisse savoir par quel nom nous l'avons appelé il suffit de mettre dans le code en plus ceci :
<file bash>
#!/bin/bash
seq=$1
beg=$2
end=$3
enz=$4

#conditions a ajouter pour verifier le nom de programme
if [ $0 == /usr/local/bin/nocutters ]
then
	filtre=/usr/local/bin/sednc
fi

if [ $0 == /usr/local/bin/cutters ]
then
	filtre=/usr/local/bin/sedc
fi

if [ $enz == all ]
then
	  enz="all"
else 
	enz="@$enz"
fi

if [ $beg == - ]
then
	beg=""
else 
	beg="-sbeg $beg"
fi


if [ $end == - ]
then
	end=""
else 
	end="-send $end"
fi
remap $1 $beg $end -sitelen 6 -enzymes $enz -outfile stdout | $filtre

</file>